// Copyright 2020 Adam Chalkley
//
// https://github.com/atc0005/go-nagios
//
// Licensed under the MIT License. See LICENSE file in the project root for
// full license information.

package nagios_test

import (
	"github.com/atc0005/go-nagios"
)

// Ignore this. This is just to satisfy the "whole file" example requirements
// per https://go.dev/blog/examples.
var _ = "https://github.com/atc0005/go-nagios"

// Pretend that this is provided by another package. Included here for
// simplicity.
type Config struct {
	EmitBranding bool
}

// Branding accepts a message and returns a function that concatenates that
// message with version information. This function is intended to be called as
// a final step before application exit after any other output has already
// been emitted.
//
// Pretend that this is provided by another package. Included here for
// simplicity.
func Branding(s string) func() string {
	return func() string {
		return s + " appended branding string"
	}
}

// ExampleUseABrandingCallback demonstrates using a branding callback to emit
// custom branding details at plugin exit. This can be useful to brand plugin
// output so that it is easier to tell which plugin generated it.
func Example_useABrandingCallback() {
	// First, create an instance of the Plugin type. By default this value is
	// configured to indicate a successful execution. This should be
	// overridden by client code to indicate the final plugin state to Nagios
	// when the plugin exits.
	var plugin = nagios.NewPlugin()

	// Second, immediately defer ReturnCheckResults() so that it runs as the
	// last step in your client code. If you do not defer ReturnCheckResults()
	// immediately any other deferred functions in your client code will not
	// run.
	//
	// Avoid calling os.Exit() directly from your code. If you do, this
	// library is unable to function properly; this library expects that it
	// will handle calling os.Exit() with the required exit code (and
	// specifically formatted output).
	//
	// For handling error cases, the approach is roughly the same, only you
	// call return explicitly to end execution of the client code and allow
	// deferred functions to run.
	defer plugin.ReturnCheckResults()

	// ...

	// In this example, we'll make a further assumption that you have a config
	// value with an EmitBranding field to indicate whether the user/sysadmin
	// has opted to emit branding information. This value might be returned
	// from another package. Here we're representing it as a literal value for
	// simplicity.
	config := Config{
		EmitBranding: true,
	}

	if config.EmitBranding {
		// If enabled, show application details at end of notification
		plugin.BrandingCallback = Branding("Notification generated by ")
	}

	// You could just as easily create an anonymous function as the callback:
	if config.EmitBranding {
		// If enabled, show application details at end of notification
		plugin.BrandingCallback = func(msg string) func() string {
			return func() string {
				return "Notification generated by " + msg
			}
		}("HelloWorld")
	}
}
